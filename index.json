[{"categories":["db"],"content":"ClickHouse时间查询 近几个小时 SELECT time FROM wiki_logs.wiki_logs where subtractHours(time, 7) \u003e toDate(now()) 今天 SELECT time FROM wiki_logs.wiki_logs where toDate(time) = today() 昨天 SELECT time FROM wiki_logs.wiki_logs where toDate(time) = yesterday() 近几天 SELECT time FROM wiki_logs.wiki_logs where subtractDays(time, 7) \u003c toDate(now()) 本月 SELECT time FROM wiki_logs.wiki_logs where toMonth(time) = toMonth(now()) 按时间段（自定义） SELECT toDate(time) t FROM wiki_logs.wiki_logs where time BETWEEN yesterday() and subtractHours(time, 1) 每天时间段内 select * from wiki_logs.wiki_logs where toYYYYMMDDhhmmss(time)%1000000 BETWEEN '123000' and '160000' 按小时分组 SELECT concat(toString(toHour(time)), '-', toString(toHour(time) + 1), '点') tacticsDate, count(*) tacticsCount FROM wiki_logs.wiki_logs GROUP BY toHour(time) 按天分组 SELECT toDate(time) tacticsDate, count(*) tacticsCount FROM wiki_logs.wiki_logs GROUP BY toDate(time) ","date":"2023-01-09","objectID":"/clickhouse-search-time/:0:1","tags":null,"title":"ClickHouse时间查询","uri":"/clickhouse-search-time/"},{"categories":["docker"],"content":"配置文件路径 sudo vim /etc/docker/daemon.json ","date":"2021-08-11","objectID":"/docker-compose-config/:0:1","tags":null,"title":"docker 配置文件","uri":"/docker-compose-config/"},{"categories":["docker"],"content":"修改配置文件 { \"registry-mirrors\": [ \"https://1nj0zren.mirror.aliyuncs.com\", \"https://docker.mirrors.ustc.edu.cn\", \"http://f1361db2.m.daocloud.io\", \"https://dockerhub.azk8s.cn\" ], \"data-root\": \"/datafile/docker\", \"default-address-pools\": [{\"base\":\"10.10.0.0/16\", \"size\": 24}] } registry-mirrors 设置镜像加速地址 data-root 设置docker文件存储位置 default-address-pools 设置docker默认网段地址 ","date":"2021-08-11","objectID":"/docker-compose-config/:0:2","tags":null,"title":"docker 配置文件","uri":"/docker-compose-config/"},{"categories":["cicd"],"content":"Jenkinsfile 文件 pipeline { agent any stages { stage('unittest and cover report') { steps { script { GIT_AUTHOR = sh (script: 'git log -1 --pretty=%cn ${GIT_COMMIT}', returnStdout: true).trim() } sh 'make mock' sh 'make lint' sh 'make test' sh 'make cover' sh 'make coverage' } post { success { cobertura coberturaReportFile: '**/coverage.xml' dingtalk ( robot: '', type: 'MARKDOWN', at: [], atAll: false, title: '[pipeline jenkins] 通知提醒', text: [ \"- 状态: \u003cfont color=#008000\u003e成功\u003c/font\u003e\", \"- 作者: ${GIT_AUTHOR}\", \"- 项目名称：${JOB_NAME}\", \"- 构建编号：${BUILD_NUMBER}\", \"- 构建日志：${BUILD_URL}\", ], ) } failure { dingtalk ( robot: '', type: 'MARKDOWN', at: [], atAll: false, title: '[pipeline jenkins] 通知提醒', text: [ \"- 状态: \u003cfont color=#DC143C\u003e失败\u003c/font\u003e\", \"- 作者: ${GIT_AUTHOR}\", \"- 项目名称：${JOB_NAME}\", \"- 构建编号：${BUILD_NUMBER}\", \"- 构建日志：${BUILD_URL}\", ], ) } } } } } ","date":"2021-04-15","objectID":"/jenkins/:0:1","tags":null,"title":"pipeline中Jenkinsfile实例","uri":"/jenkins/"},{"categories":["cicd"],"content":"参考 https://www.cnblogs.com/chenyishi/p/10943352.html ","date":"2021-04-15","objectID":"/jenkins/:0:2","tags":null,"title":"pipeline中Jenkinsfile实例","uri":"/jenkins/"},{"categories":["linux"],"content":"前略 本文使用的是 shadowsocks-go fail2ban 安装省略 ss日志目录在 /root/script/ss-log ","date":"2020-12-24","objectID":"/fail2ban/:0:1","tags":null,"title":"fail2ban 保护ss ","uri":"/fail2ban/"},{"categories":["linux"],"content":"ss 错误格式 2020/12/23 23:02:02 error getting request 101.227.27.183:58512 xx.xx.xx.xx:xxxx addr type 0 not supported ","date":"2020-12-24","objectID":"/fail2ban/:0:2","tags":null,"title":"fail2ban 保护ss ","uri":"/fail2ban/"},{"categories":["linux"],"content":"fail2ban 端设置 新建一个规则 sudo vi /etc/fail2ban/filter.d/shadowsocks.conf 添加内容: [INCLUDES] before = common.conf [Definition] _daemon = shadowsocks failregex = ^\\s+error getting request \u003cHOST\u003e:\\d+ \\s* ignoreregex = failregex 验证 fail2ban-regex '2020/12/23 23:02:02 error getting request 101.227.27.183:58512 10.0.0.11:9999 addr type 0 not supported' '^\\s+error getting request \u003cHOST\u003e:\\d+ \\s*' 更新 fail2ban 配置 sudo vi /etc/fail2ban/jail.local [shadowsocks] enabled = true filter = shadowsocks port = 0:65535 logpath = /root/script/ss-log maxretry = 5 bantime = 43200 ","date":"2020-12-24","objectID":"/fail2ban/:0:3","tags":null,"title":"fail2ban 保护ss ","uri":"/fail2ban/"},{"categories":["linux"],"content":"重启 fail2ban systemctl restart fail2ban.service ","date":"2020-12-24","objectID":"/fail2ban/:0:4","tags":null,"title":"fail2ban 保护ss ","uri":"/fail2ban/"},{"categories":["linux"],"content":"查看监控状态 sudo fail2ban-client status shadowsocks ","date":"2020-12-24","objectID":"/fail2ban/:0:5","tags":null,"title":"fail2ban 保护ss ","uri":"/fail2ban/"},{"categories":["software"],"content":"解决方法 将dumpcap更改为Wireshark用户组 sudo chgrp wireshark /usr/bin/dumpcap 让Wireshark用户组有root权限使用dumpcap sudo chmod 4755 /usr/bin/dumpcap 将自己加入Wireshark用户组,我的用户是 abc ,你添加需要更改这个 sudo gpasswd -a abc wireshark ","date":"2020-11-07","objectID":"/use-wireshark/:0:1","tags":null,"title":"Linux普通用户使用Wireshark的权限不足的问题","uri":"/use-wireshark/"},{"categories":["golang"],"content":"直接上Demo package main import ( \"fmt\" \"os\" \"sort\" \"text/tabwriter\" ) type Student struct { name string age int score int } var students []*Student func printStudents(students []*Student) { const format = \"%v\\t%v\\t%v\\t\\n\" tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0) fmt.Fprintf(tw, format, \"name\", \"age\", \"score\") fmt.Fprintf(tw, format, \"----\", \"---\", \"---\") for _, s := range students { fmt.Fprintf(tw, format, s.name, s.age, s.score) } tw.Flush() } type studentSort struct { s []*Student less func(x, y *Student) bool } func (x studentSort) Len() int { return len(x.s) } func (x studentSort) Less(i, j int) bool { return x.less(x.s[i], x.s[j]) } func (x studentSort) Swap(i, j int) { x.s[i], x.s[j] = x.s[j], x.s[i] } func init() { students = []*Student{ \u0026Student{\"Adam\", 20, 60}, \u0026Student{\"Bob\", 18, 60}, \u0026Student{\"Clark\", 19, 70}, \u0026Student{\"Daisy\", 18, 70}, \u0026Student{\"Eva\", 20, 80}, \u0026Student{\"Frank\", 20, 60}, \u0026Student{\"Gideon\", 19, 30}, } } func main() { // 第一次可以使用非稳定排序 sort.Sort(studentSort{students, func(x, y *Student) bool { if x.name != y.name { return x.name \u003c y.name } return false }}) // 第二次之后就需要使用稳定排序，不然之前的排序又会被打乱 sort.Stable(studentSort{students, func(x, y *Student) bool { if x.score != y.score { return x.score \u003e y.score } return false }}) sort.Stable(studentSort{students, func(x, y *Student) bool { if x.age != y.age { return x.age \u003c y.age } return false }}) printStudents(students) } ","date":"2020-10-28","objectID":"/multi-sort/:0:1","tags":null,"title":"Golang 多个字段顺序排序","uri":"/multi-sort/"},{"categories":["golang"],"content":"结果 首先根据年龄升序排序，然后根据成绩降序排序，最后根据名称升序排序 ","date":"2020-10-28","objectID":"/multi-sort/:0:2","tags":null,"title":"Golang 多个字段顺序排序","uri":"/multi-sort/"},{"categories":["golang"],"content":"参考 https://blog.51cto.com/steed/2390923 ","date":"2020-10-28","objectID":"/multi-sort/:0:3","tags":null,"title":"Golang 多个字段顺序排序","uri":"/multi-sort/"},{"categories":["golang"],"content":" package main import ( \"fmt\" \"sync\" \"time\" ) /** *ticker只要定义完成，从此刻开始计时，不需要任何其他的操作，每隔固定时间都会触发。 *timer定时器，是到固定时间后会执行一次 *如果timer定时器要每隔间隔的时间执行，实现ticker的效果，使用 func (t *Timer) Reset(d Duration) bool */ func main() { var wg sync.WaitGroup wg.Add(2) //NewTimer 创建一个 Timer，它会在最少过去时间段 d 后到期，向其自身的 C 字段发送当时的时间 timer1 := time.NewTimer(2 * time.Second) //NewTicker 返回一个新的 Ticker，该 Ticker 包含一个通道字段，并会每隔时间段 d 就向该通道发送当时的时间。它会调 //整时间间隔或者丢弃 tick 信息以适应反应慢的接收者。如果d \u003c= 0会触发panic。关闭该 Ticker 可 //以释放相关资源。 ticker1 := time.NewTicker(2 * time.Second) go func(t *time.Ticker) { defer wg.Done() for { \u003c-t.C fmt.Println(\"get ticker1\", time.Now().Format(\"2006-01-02 15:04:05\")) } }(ticker1) go func(t *time.Timer) { defer wg.Done() for { \u003c-t.C fmt.Println(\"get timer\", time.Now().Format(\"2006-01-02 15:04:05\")) //Reset 使 t 重新开始计时，（本方法返回后再）等待时间段 d 过去后到期。如果调用时t //还在等待中会返回真；如果 t已经到期或者被停止了会返回假。 t.Reset(2 * time.Second) } }(timer1) wg.Wait() } ","date":"2020-10-27","objectID":"/timer/:0:0","tags":null,"title":"golang的定时器NewTimer、NewTicker使用","uri":"/timer/"},{"categories":["golang"],"content":"额外说明 time.NewTicker定时触发执行任务，当下一次执行到来而当前任务还没有执行结束时，会等待当前任务执行完毕后再执行下一次任务。查阅go官网的文档和经过代码验证。 time.NewTimer和Reset()函数实现定时触发，Reset()函数可能失败，经测试。 ","date":"2020-10-27","objectID":"/timer/:0:1","tags":null,"title":"golang的定时器NewTimer、NewTicker使用","uri":"/timer/"},{"categories":["golang"],"content":"Refer https://learnku.com/articles/23578/the-difference-between-go-timer-and-ticker ","date":"2020-10-27","objectID":"/timer/:0:2","tags":null,"title":"golang的定时器NewTimer、NewTicker使用","uri":"/timer/"},{"categories":["docker"],"content":"安装 创建 docker_kafka 的目录 参考官方测试用的docker-compose.yml直接在自定义的目录位置新建docker-compose的配置文件 version:'3'services:zookeeper:container_name:zookeeperimage:wurstmeister/zookeeperkafka:container_name:kafkaimage:wurstmeister/kafkaports:- 9092:9092depends_on:- \"zookeeper\"environment:KAFKA_ADVERTISED_HOST_NAME:kafkaKAFKA_ZOOKEEPER_CONNECT:zookeeper:2181kafka-manager:container_name:kafka-managerimage:hlebalbau/kafka-managerports:- 9020:9000environment:ZK_HOSTS:zookeeper:2181 注意： KAFKA_ADVERTISED_HOST_NAME 需要配置为宿主机的ip docker-compose 启动kafka root@ubuntu:~/docker/kafka# docker-compose up -d ","date":"2020-10-20","objectID":"/docker-kafka/:0:1","tags":null,"title":"使用Docker-compose快速搭建Kafka开发环境","uri":"/docker-kafka/"},{"categories":["docker"],"content":"验证 首先进入到一个kafka容器中，例如: kafka root@ubuntu:~/docker/kafka# docker exec -it kafka /bin/bash 创建一个topic并查看，需要指定zookeeper的容器名(这里是docker_kafka_kafka_1)，topic的名字为test $KAFKA_HOME/bin/kafka-topics.sh --create --topic test --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 $KAFKA_HOME/bin/kafka-topics.sh --list --zookeeper zookeeper:2181 发布消息，输入几条消息后，按^C退出发布 $KAFKA_HOME/bin/kafka-console-producer.sh --topic=test --broker-list kafka:9092 接受消息 $KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --from-beginning --topic test ","date":"2020-10-20","objectID":"/docker-kafka/:0:2","tags":null,"title":"使用Docker-compose快速搭建Kafka开发环境","uri":"/docker-kafka/"},{"categories":["docker"],"content":"kafka-manager 添加数据问题 Yikes! KeeperErrorCode = Unimplemented for /Kafka-Manager/mutex Try Again CMAK添加集群的时候报错 参考网址 https://github.com/yahoo/CMAK/issues/731 my docker image version zookeeper:3.4.14 wurstmeister/kafka:2.12-2.4.1 kafkamanager/kafka-manager:3.0.0.4 this worked for me ➜ docker exec -it zookeeper bash root@98747a9eac65:/zookeeper-3.4.14# ./bin/zkCli.sh [zk: localhost:2181(CONNECTED) 2] ls /kafka-manager [configs, deleteClusters, clusters] [zk: localhost:2181(CONNECTED) 3] create /kafka-manager/mutex \"\" Created /kafka-manager/mutex [zk: localhost:2181(CONNECTED) 5] create /kafka-manager/mutex/locks \"\" Created /kafka-manager/mutex/locks [zk: localhost:2181(CONNECTED) 6] create /kafka-manager/mutex/leases \"\" Created /kafka-manager/mutex/leases ","date":"2020-10-20","objectID":"/docker-kafka/:0:3","tags":null,"title":"使用Docker-compose快速搭建Kafka开发环境","uri":"/docker-kafka/"},{"categories":["linux"],"content":"概述 在Linux上增加swap空间的方法有两种： 在安装时手动分配swap，对于这种方式，空间大小是事先规划好的，每次系统启动时会自动进行挂载，但这种方法只能在安装OS时设定，一旦设定好不容易改变，除非重装系统。 使用swapfile: 新建临时swapfile或者是空闲分区，在需要的时候设定为交换空间，最多可以增加8个swapfile。 Redhat6.4官方推荐的系统交换空间: 系统中的RAM大小 建议交换空间 如果允许休眠建议使用交换空间 ⩽2GB RAM的2倍 RAM数量的3倍 \u003e 2GB - 8GB 等于RAM的数量 RAM的2倍 \u003e 8GB - 64GB 至少4 GB RAM的1.5倍 \u003e 64GB 至少4 GB 不建议休眠 因为有些系统会允许休眠状态，如果不设置swap会无法启动，就像windows系统使用休眠设置虚拟内存一样。使用这种方法比较灵活，也比较方便，缺点是启动系统后需要手工设置。 还有其他一些博客中有下面一个推荐设置，我也不清楚是怎么得到这个标准的，是否合理也无从考证，可以作为一个参考： 系统中的RAM大小 建议交换空间 ⩽ 4G SWAP 设置为内存的2倍 4G-8G SWAP 等于内存大小 8G-64G SWAP 设置为8G 64G-256G SWAP 设置为16G 如何选择可以考虑以下几个情况： 物理内存空间是否在峰值也可以满足要求，不满足建议设置swap防止内存溢出导致主机宕机，当然设置不宜过大，占用磁盘空间。 磁盘I/O是否足够，使用磁盘I/O值过低或者其他业务要求高，不建议设置swap。由于使用swap需要频繁写入磁盘，使用固态硬盘不建议设置（固态硬盘PE写入次数有限，因此寿命要比机械硬盘更低，考虑到使用寿命当然就尽量减少写入次数） 服务器安装的具体的应用，比如Mysql等不推荐设置，可以不设置或者修改参数swappiness来控制的，默认值为 60意思是说在内存使用40%的情况下就使用swap空间，可以将值设置为10 或者设置0，优先使用物理内存。 对于我使用manjaor linux作为日常操作系统用的就没有上述的考虑了，根据自己的使用情况，8G内存我设置8G或者2G其实都够用 分配swapfile作为交换空间步骤如下： ","date":"2020-10-10","objectID":"/swapfile/:1:0","tags":null,"title":"如何为Linux新增swap交换空间","uri":"/swapfile/"},{"categories":["linux"],"content":"步骤 首先运行 free -h 查看一下物理内存大小和swap 总计 已用 空闲 共享 缓冲/缓存 可用 内存： 7.7Gi 2.3Gi 2.3Gi 612Mi 3.1Gi 4.5Gi 交换： 0Gi 0B 0Gi 我的显示8G并没有分配swap空间所以为0 创建swapfile文件 # 切换到根路径 $ cd / # 这里只需要改count的大小即可比如分配8G就是8，bs是单位 # swapfile的位置是/var/swapfile也可以自己修改，名称也可以不叫swapfile,自己指定 $ sudo dd if=/dev/zero of=/var/swapfile bs=1G count=8 8+0 的读入 8+0 的写出 8589934592 bytes (8.1 GB) copied, 40.55445 s, 202 MB/s mkswap创建交换文件 $ sudo mkswap /var/swapfile swapon激活 $ swapon /var/swapfile 查看增加后swap空间 $ free -h 总计 已用 空闲 共享 缓冲/缓存 可用 内存： 7.7Gi 2.3Gi 2.3Gi 612Mi 3.1Gi 4.5Gi 交换： 8Gi 0B 8Gi 设置开机自动挂载 $ sudo vim /etc/fstab 在其中添加一行 /var/swapfile swap swap defaults 0 0 添加之后我的完整fstab文件如下，自行参考： # /etc/fstab: static file system information. # # Use 'blkid' to print the universally unique identifier for a device; this may # be used with UUID= as a more robust way to name devices that works even if # disks are added and removed. See fstab(5). # # \u003cfile system\u003e \u003cmount point\u003e \u003ctype\u003e \u003coptions\u003e \u003cdump\u003e \u003cpass\u003e /var/swapfile swap swap defaults 0 0 /dev/sdb3 /home/guqing/guqing ext4 defaults 0 0 UUID=A402-DC5E /boot/efi vfat umask=0077 0 2 UUID=21d03dc0-948a-4adc-969c-3160a29aeef2 / ext4 defaults,noatime 0 1 其中/dev/sdb3一行是因为我挂载了磁盘的缘故 然后执行,自动挂载所有在fstab中的文件系统 $ mount -a 到此就可以使用swapfile了 ","date":"2020-10-10","objectID":"/swapfile/:2:0","tags":null,"title":"如何为Linux新增swap交换空间","uri":"/swapfile/"},{"categories":["linux"],"content":"去掉swap 如果不想使用swap空间了，可以使用如下方法删除swapfile # 停用 $ sudo swapoff /var/swapfile # 删除swapfile,路径为创建时制定的，/var/swapfile $ sudo rm -f /var/swapfile # 确认 $ free -h ","date":"2020-10-10","objectID":"/swapfile/:3:0","tags":null,"title":"如何为Linux新增swap交换空间","uri":"/swapfile/"},{"categories":["linux"],"content":"Refer https://guqing.xyz/archives/linux-swapfile ","date":"2020-10-10","objectID":"/swapfile/:4:0","tags":null,"title":"如何为Linux新增swap交换空间","uri":"/swapfile/"},{"categories":["software"],"content":"Mac 删除 ~/Users/abc/Library/Logs/ 下面的所有 intel 开头的目录和 JetBrains 目录 删除 ~/Users/abc/Library/Preferences/ 下面的所有 intel 开头的目录和 JetBrains 目录 删除 ~/Users/abc/Library/Caches/ 下面的所有 intel 开头的目录和 JetBrains 目录 删除 ~/Users/abc/Library/Application\\ Support/ 下面的所有 intel 开头的目录和 JetBrains 目录 删除所有的 ~/.idea 或者在其它目录下面的.idea 目录 ","date":"2020-09-12","objectID":"/idea-uninstall/:1:0","tags":null,"title":"idea 干净卸载以及配置文件所在位置","uri":"/idea-uninstall/"},{"categories":["software"],"content":"引用 https://www.jetbrains.com/help/idea/uninstall.html?section=macOS#standalone ","date":"2020-09-12","objectID":"/idea-uninstall/:2:0","tags":null,"title":"idea 干净卸载以及配置文件所在位置","uri":"/idea-uninstall/"},{"categories":["software"],"content":"更多配置文件的位置 https://www.jetbrains.com/help/idea/tuning-the-ide.html#configure-platform-properties ","date":"2020-09-12","objectID":"/idea-uninstall/:3:0","tags":null,"title":"idea 干净卸载以及配置文件所在位置","uri":"/idea-uninstall/"},{"categories":["linux"],"content":"Openwrt 命令行配置上网并安装web界面 # 登录路由器 ssh root@192.168.1.1 #更改密码 passwd #配置文件地址 /etc/config/network # pppoe设置上网帐号 uci set network.wan.proto=pppoe uci set network.wan.username=帐号 uci set network.wan.password=密码 # 重启网络 /etc/init.d/network restart # 是否能正常上网 ping 8.8.8.8 # 更新安装源 opkg update # 安装web插件 opkg install --force-depends luci /etc/init.d/uhttpd enable /etc/init.d/uhttpd start # 登录网页 http://192.168.1.1/cgi-bin/luci/ ","date":"2020-09-06","objectID":"/openwrt/:0:1","tags":null,"title":"Openwrt 命令行配置上网并安装web界面","uri":"/openwrt/"},{"categories":["software"],"content":"使用以下命令更换国内阿里云上的homebrew镜像： # 替换brew.git: cd \"$(brew --repo)\" git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 替换homebrew-bottles: echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' \u003e\u003e ~/.zshrc source ~/.zshrc # 替换homebrew-cask.git: cd \"$(brew --repo)\"/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git ","date":"2020-07-10","objectID":"/homebrew/:0:1","tags":null,"title":"更换Homebrew源","uri":"/homebrew/"},{"categories":["git"],"content":"git命令 ","date":"2020-06-26","objectID":"/submodule/:0:1","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"添加子模块 git submodule add git@github.com:MeiK2333/github-style.git themes/github-style 然后可以看到目录下出现了.gitmodules文件，其中记录了子模块保持地址及Url [submodule \"themes/github-style\"] path = themes/github-style url = https://github.com/MeiK2333/github-style.git ","date":"2020-06-26","objectID":"/submodule/:0:2","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"查看子模块 git submodule ","date":"2020-06-26","objectID":"/submodule/:0:3","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"初始化及更新子模块 git submodule init //初始化本地的子模块配置文件，在拉取了一个带有子模块的工程后，需要先执行init git submodule update //更新子模块（如子模块文件夹为空，则会下载子模块） ","date":"2020-06-26","objectID":"/submodule/:0:4","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"提交子模块修改 当子模块有修改时，在主项目上git status并不会完全显示修改的文件，只会显示被修改的子文件夹，如 modified: themes/github-style (modified content) 然后需要进入子模块进行常规的add，commit等操作，将子模块的改动提交 cd themes/github-style git add --a git commit -s -m\"Modify submodule\" 此时回到主工程, 用diff语句查看改动，可以看到改动的是子模块最新的commit ID，这可以理解为主工程保留了每个子模块最新的commit ID指针，当运行git submodule update时，就是将每个子模块更新至各自最新的commit ID git diff themes/github-style 将这个改动提交，那么远程仓库也就更新了子模块的最新指针。 ","date":"2020-06-26","objectID":"/submodule/:0:5","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"删除子模块 删除.gitmodules中的子模块内容 删除.git/config中的子模块内容 删除.git/modules中的子模块对应文件夹 运行git rm –cached -r themes/next删除对应子模块文件夹的索引 删除子模块文件夹 ","date":"2020-06-26","objectID":"/submodule/:0:6","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"常见问题 xxx already exists in the index 出现在git submodule add时，说明同一文件夹路径下有其他子模块。如果已经手动删除，错误仍然存在，可能是路径索引导致，需要完整执行删除子模块操作。 server does not allow request for unadvertised object 出现在git submodule update时，说明主工程中保持的最新的子模块commit id，无法在服务器子模块工程中找到，可能是因为子模块改动未提交，或者提交分支错误导致commit id改变。 ","date":"2020-06-26","objectID":"/submodule/:0:7","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["git"],"content":"Refer https://xuejiaw.github.io/gitSubmoduleTutorial/ ","date":"2020-06-26","objectID":"/submodule/:0:8","tags":null,"title":"Git 子模块 Submodule 教程","uri":"/submodule/"},{"categories":["software"],"content":"clash 设置终端代理 alias setproxy=\"export https_proxy=http://127.0.0.1:7890;export http_proxy=http://127.0.0.1:7890;export all_proxy=socks5://127.0.0.1:7891;echo \\\"Set proxy successfully\\\" \" alias unsetproxy=\"unset http_proxy;unset https_proxy;unset all_proxy;echo \\\"Unset proxy successfully\\\" \" ","date":"2020-06-26","objectID":"/clash/:0:1","tags":null,"title":"Clash 相关操作","uri":"/clash/"},{"categories":["software"],"content":"clash 自动更新订阅 clash.service # edit and save this file to /usr/lib/systemd/user/clash.service [Unit] Description=clash After=network.target [Service] WorkingDirectory=\"your home directory\"/.config/clash ExecStart=\"your home directory\"/.config/clash/start-clash.sh ExecStop=\"your home directory\"/.config/clash/stop-clash.sh Environment=\"HOME=your home directory\" Environment=\"CLASH_URL=your subscribe address\" [Install] WantedBy=multi-user.target start-clash.sh #!/bin/bash # save this file to ${HOME}/.config/clash/start-clash.sh # save pid file echo $$ \u003e ${HOME}/.config/clash/clash.pid diff ${HOME}/.config/clash/config.yaml \u003c(curl -s ${CLASH_URL}) if [ \"$?\" == 0 ] then /usr/bin/clash else TIME=`date '+%Y-%m-%d %H:%M:%S'` cp ${HOME}/.config/clash/config.yaml \"${HOME}/.config/clash/config.yaml.bak${TIME}\" curl -L -o ${HOME}/.config/clash/config.yaml ${CLASH_URL} /usr/bin/clash fi stop-clash.sh #!/bin/bash # save this file to ${HOME}/.config/clash/stop-clash.sh # read pid file PID=`cat ${HOME}/.config/clash/clash.pid` kill -9 ${PID} rm ${HOME}/.config/clash/clash.pid 配置添加完成后，执行以下代码就可以启动Clash并设置为开机自启动。 systemctl --user enable clash systemctl --user start clash ","date":"2020-06-26","objectID":"/clash/:0:2","tags":null,"title":"Clash 相关操作","uri":"/clash/"},{"categories":["software"],"content":"起因 jumpserver 登陆时间有限制， 过段时间就会被登出， 每次登陆都要输入Google的身份验证器的验证码。非常的不方便。 ","date":"2020-06-22","objectID":"/jump-server/:0:1","tags":null,"title":"一步登陆 jumpserver 跳板机 告别Google的身份验证器","uri":"/jump-server/"},{"categories":["software"],"content":"解决方案 网上找到了方案 使用 expect 和 oathtool 去解决问题： expect 是自动化控制和测试的工具，可以使用脚本来对终端进行自动化控制。 https://zh.wikipedia.org/wiki/Expect oathtool 应该是Google的身份验证器加密的一种方式 （猜的） https://www.nongnu.org/oath-toolkit/man-oathtool.html ","date":"2020-06-22","objectID":"/jump-server/:0:2","tags":null,"title":"一步登陆 jumpserver 跳板机 告别Google的身份验证器","uri":"/jump-server/"},{"categories":["software"],"content":"使用python实现代码 环境安装 pip install oathtool pip install pexpect 代码部分 import pexpect import oathtool import struct import fcntl import sys import termios # 此函数用来设置合适的窗口大小 def getwinsize(): \"\"\"This returns the window size of the child tty. The return value is a tuple of (rows, cols). \"\"\" if 'TIOCGWINSZ' in dir(termios): TIOCGWINSZ = termios.TIOCGWINSZ else: TIOCGWINSZ = 1074295912 # Assume s = struct.pack('HHHH', 0, 0, 0, 0) x = fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ, s) return struct.unpack('HHHH', x)[0:2] child = pexpect.spawn('ssh your-user@your-host ') child.expect('MFA') # 这个判断你想要出现字符， 我这里是MFA passwd = oathtool.generate_otp(\"你的身份验证器的密钥\") child.sendline(passwd) # 发送验证码 # 自适应窗口大小， 防止vim等显示的数据错乱，串行等 winsize = getwinsize() child.setwinsize(winsize[0], winsize[1]) child.interact() # 把ssh的连接交给用户控制。 child.close() 写好 alias 这里省略 ","date":"2020-06-22","objectID":"/jump-server/:0:3","tags":null,"title":"一步登陆 jumpserver 跳板机 告别Google的身份验证器","uri":"/jump-server/"},{"categories":null,"content":"Hello pureboys 这个是我的个人博客 ","date":"2020-06-22","objectID":"/about/:0:1","tags":null,"title":"About","uri":"/about/"}]